module GraceToJVM

import Node;
import IO;
import lang::json::IO;
import util::ValueUI;
import ValueIO;
import lang::jvm::ast::Level0; 
import lang::jvm::transform::SerializeClass;
import util::UUID;
import String;

// we have a rather broad definition of what Grace is here, with lots of top types,
// because that allows us to easily map the untyped json representation to it. to be improved, because
// matching on types is not easy with this representation, you need to match on constructors always.
data Program = program(list[value] chunks);

data Meth = method(str name, list[value] params, list[value] body);

data Chunk = chunk(int x, int y, list[value] body);

data Def 
  = defdec(str name, value val)
  | internalKind(str kind, str typ)
  | inherits(value parent)
  ;

data Exp 
  = operator(str op, value lhs, value rhs)
  | number(num n)
  | selfcall(str name, list[value] params, bool isRequest)
  | dialectMethod(str name, list[value] parts)
  | request(value receiver, str name, list[value] args)
  | var(str name)
  | string(str val)
  | assign(str name, value exp)
  | block(list[value] params, list[value] body)
  | object(value elems)
  ;


@doc{
Below, in the toGrace definitions, we list how json objects (represented as sets with a fixed arity here, are mapped
to the above data definitions. Its a temporary solution while we use json as transport medium.
toGrace works via "set matching", so the order of the elements
is irrelevant. The distinctions are made by matching (mostly) on the labels of the json fields, and
especially the value of the "type" field in most of the objects
}
value toGrace({<"chunks", list[value] c>}) 
  = program(c);
  
value toGrace({<"type","method">, <"body", b>, <"name", n>, <"arg", a>}) 
  = method(n, a, b);
  
value toGrace({<"type", "operator">, <"left", l>, <"right", r>, <"operator", op>})
  = operator(op, l, r);
  
value toGrace({<"type", "number">, <"value", n>}) 
  = number(readTextValueString(#num, n));
  
value toGrace({<"type","selfcall">, <"name", n>, <"isRequest",r>, <"args",a>}) 
  = selfcall(n, a, r);
  
value toGrace({<"name",n>, <"type","dialect-method">,<"parts",ps>}) 
  = dialectMethod(n, [p | [p] <- ps]);
  
value toGrace({<"args",a>, <"receiver",r>,<"type","request">, <"name",n>}) 
  = request(r, n, a);
  
value toGrace({<"value",n>, <"type","var">}) 
  = var(n);
  
value toGrace({<"value",v>, <"type","string">}) 
  = string(v);
  
value toGrace({<"type","chunk">, <"x", /<x:[0-9]+>/>,  <"y", /<y:[0-9]+>/>, <"body", b>}) 
  = chunk(readTextValueString(#int,x), readTextValueString(#int,x), b); 
  
value toGrace({<"type","defdec">, <"value", v>, <"name", n>}) 
  = defdec(n, v);
  
value toGrace({<"type", "block">, <"params", ps>, <"body", b>}) 
  = block(ps, b);
  
value toGrace({<"type", "object">, <"body", b>}) 
  = object(b);
  
value toGrace({<"internalKind", str k>, <"type", str t>}) 
  =  internalKind(k, t);
  
value toGrace({<"type", "inherits">, <"parent", value v>}) 
  = inherits(v);

value toGrace({set[value] nested}) = nested;

default value toGrace({*value elems}) {
  println("new kind of json detected, failing on: <elems>");
  return elems;
}

// note that visit's substitutions need to be type preserving, and since we want to replace
// sets by tree nodes here, we are matching any value.
value simplify(value json) = visit(json) {
  case value x => toGrace(s) when set[value] s := x 
};

value mapsToRel(value p) = visit(p) {
  case value x => {<y,m[y]> | y <- m } when map[value,value] m := x
}; 

str fresh() = "tmp_<uuidi()>";

// I just did some guesses here. It really depends on some of the semantics of Grace if this is ok
value flatten(value exp) = visit(exp) {
  case block(ps, [*a, e, *c]) 
    => block(ps, [*a, *b, *c]) when block([], [*b]) := e // serialize nested blocks generated by the following cases
  case [block([],a)] => a
  case assign(str v, block([], [*pre, last]))
    => block([], [*pre, assign(v, [last])])
  case operator(op, l, r) 
    => block([], [assign(a,l), operator(op, var(a), r)]) when !(l is var), a := fresh()
  case operator(op, l, r) 
    => block([], [assign(b,l), operator(op, l, var(b))]) when !(r is var), b := fresh()  
  case request(rec, str name, list[value] args)
    => block([], [assign(a,rec), request(var(a), name, args)]) when !(rec is var), a := fresh()
  case request(rec, str name, [*pre, v, *post])
    => block([], [assign(a,v), request(rec, name, [*pre,var(a),*post])]) when var(_) !:= v, a := fresh()
  case selfcall(str name, [*x, v, *y], r)
    => block([], [assign(a,v), selfcall(name, [*x,var(a),*y], r)]) when var(_) !:= v, a := fresh() 
  case dialectMethod(str name, [*x, v, *y])
    => block([], [assign(a,v), dialectMethod(name, [*x,var(a),*y])]) when var(_) !:= v, a := fresh()      
};
 

@doc{compiles a Grace method to a JVM method}
Method makeMethod(Meth m) 
  =  method(ACC_PUBLIC, 
            m.name, 
            methodSig([objectSig() | _ <- m.params],objectSig()), // description
            methodSig([objectSig() | _ <- m.params],objectSig()), // signature
            [], // exceptions
	        [], // instructions
	        [], // tryCatchBlocks,
		    []  // localVariables
    );

Field makeField(str name, value n)
  = field(ACC_PUBLIC, name, objectSig(), objectSig(), n /*this n value still needs compilation*/);
  
@doc{compiles a Grace program to a JVM class}  
Class compile(Program p) 
  = class(V1_7, ACC_PUBLIC, "GraceRunner", classSig("GraceRunner"), "java.lang.Object", 
        [], // interfaces
        [], // innerclasses
        [makeField(n,v) | /defdec(n,v) := p], // fields
        [makeMethod(m) | /Meth m := p]  // methods
  );

@doc{test and debug function}
tuple[Program p, Class cl] tryIt() {
  f = |project://Grace/src/f2c.json|;
  a = readTextJSonFile(f);
  
  // relations are easier to pattern match and search than maps are at the moment, 
  // so we use a function to translate all maps to relations.
  b = mapsToRel(a);
  
  // here we infer the hierarchical structure which is lost by the encoding
  // in json. Since JSon objects are anonymous, they don't have a good name.
  // TODO: it would perhaps be better if the Grace parser would print a format which retained the names
  // of AST nodes, as in: class("HelloWorld", [ method("main", [], ...) ] ). Or even printing
  // it directly as Rascal expressions.  
  c = simplify(b);
  
  // now we introduce temporaries to flatten the nested structures
  solve (c) 
    c = flatten(c);
  
  // opens an editor with the result, just for debugging purposes.
  //text(c);
  
  if (Program p := c) {
    cl = compile(p);
    serialize(cl, |project://Grace/bin/GraceRunner.class|);
    return <p,cl>;
  }
  
  throw "unexpected return value";
}
    
  

            